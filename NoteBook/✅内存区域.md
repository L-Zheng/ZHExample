####栈区（stack）：存放函数的参数值，局部变量等。函数运行临时占用内存
- 由编译器自动分配并释放。
- 栈是系统数据结构，对应线程/进程是唯一的。
- 优点是快速高效**由系统自动分配，速度较快，不会产生内存碎片**，缺点是有限制，数据不灵活。**［先进后出］**
- iOS系统内，每个进程分配到的栈区内存空间为1-2M。

**栈空间分 静态分配 和 动态分配 两种**
- 静态分配是编译器完成的，比如自动变量(auto)的分配。
- 动态分配由alloca函数完成，无需释放(是自动的)，也就没有释放函数。【为可移植的程序起见，栈的动态分配操作是不被鼓励的！】

**申请响应**
- 编译器分配和释放，在函数执行时分配，在函数结束时收回。只要栈区剩余内存大于所申请的内存，那么系统将为程序提供内存
- 栈是向低地址扩展的数据结构**从高到低分配**，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

> **为什么函数运行的变量放在栈区**
栈区的先进后出，后进先出的特点：函数层层调用，最内层的函数最先结束。【最内层调用的函数最后入栈，最先出栈】。

####堆区(heap) ：存放iOS对象（alloc的对象）
- 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。
- 堆是函数库内部数据结构，不一定唯一。
- 优点是灵活方便，数据适应面广泛，但是效率有一定降低**alloc分配的内存，速度比较慢，容易产生内存碎片，不过用起来最方便**。
- 不同堆分配的内存无法互相操作。

**堆空间只有动态分配**

**申请响应**
- 系统有一个存放空闲内存地址的链表，当程序员申请堆内存的时候，系统会遍历这个链表，找到第一个内存大于所申请内存的堆节点，并把这个堆节点从链表中移除。由于这块内存的大小很多时候不是刚刚好所申请的一样大，所以剩余的那一部分还会回到这个空闲链表中。

- 堆是向高地址扩展的数据结构**从低到高分配**，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

> 堆区地址小于栈区地址

####全局区(静态区) (static) ：存放全局变量、静态变量
**分为 未初始化全局区、初始化全局区**
- 未初始化全局区：.bss段【static int c;】
- 初始化全局区：data段【static int c = 10;】

####字常量区：存放常量字符串，int常量，程序结束后由系统释放
####程序代码区 ：放函数的二进制代码
```
int a = 1; //全局变量分配在全局区
static int b = 2; //静态全局变量分配在全局区
main{
   int b; 栈区
   char s[] = "abc" 栈区
   char *p1; 栈区
   char *p2 = "123456";  123456\\\\0在常量区，p2在栈区。
   static int c =0； 全局（静态）初始化区 

   w1 = (char *)malloc(10); 
   w2 = (char *)malloc(20); 
   分配得来得10和20字节的区域就在堆区。 

    NSString *string = @"abcd"; //string局部变量分配在栈区,@"abcd"字符串分配在文字常量区
    NSArray *array = [[NSArray alloc] init]; //array局部变量分配在栈区,后面创建的OC对象分配在堆区,栈区的指针指向堆区的对象。
}
```

> **程序结束时所有的数据空间【各个区 】都会被释放回系统。**

![image.png](https://upload-images.jianshu.io/upload_images/4115164-4f8a460de527c9a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


####运行流程
程序运行的时候，操作系统会给它分配一块内存，用来存储程序和运行产生的数据，比如从 0x1000 到 0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。

![image.png](https://upload-images.jianshu.io/upload_images/4115164-b6e562bd4a1a1ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

程序运行过程中，对于动态的内存占用请求（比如新建对象），系统就会从预先分配好的那段内存中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址 0x1000 开始给他分配，一直分配到 0x100A，如果在要求得到 22 个字节，那么就分配到 0x1020

![image.png](https://upload-images.jianshu.io/upload_images/4115164-05c4cc831aad7d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这种因为用户主动请求而划分出来的内存区域，叫做 Heap(堆)。它由起始位置开始，从低位（地址）向高位（地址）增长。 Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

除了 Heap 外，其他的内存占用叫做 Stack(栈)。简单来说，Stack 是由于函数运行而临时占用的内存区域

![image.png](https://upload-images.jianshu.io/upload_images/4115164-326b0dc9d639e677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

请看下面的例子：
```
int main() {
    int a = 2;
    int b = 3;
}
```
上面代码中，系统开始执行 main 函数时，会为它在内存里面建立一个 帧（frame），所有的 main 的内部变量（比如 a 和 b）都保存在这个 帧 里面。main 函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。

![image.png](https://upload-images.jianshu.io/upload_images/4115164-84a436e193ef0071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如果函数内部调用其他函数，会发生什么情况呢？
```
int main() {
    int a = 2;
    int b = 3;
    return add_a_and_b(a,b);
}
```
上面代码中，main 函数调用了 add_a_and_b 函数。执行到这一行的时候，系统也会为 add_a_and_b 新建一个 帧（frame），用来存储它的内部变量。也就是说，此时同时存在两个帧：main 和 add_a_and_b。一般来说，调用栈有多少层，就有多少帧。

![image.png](https://upload-images.jianshu.io/upload_images/4115164-8bbefb03a7f2e895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

等到 add_a_and_b 运行结束，它的帧就会被回收，系统会回到刚才 main 函数中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

所有的帧都存放在 Stack ，由于帧是一层层叠加的，所以 Stack 叫做 栈。生成新的帧，叫 入栈，英文单词是 push；栈的回收叫 出栈，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束执行），这种叫做 后进先出 的数据结构。每一次函数执行结束，就自动释放一个帧，所有的函数执行结束，整个 Stack 就都释放了。

Stack 是由内存区域的结束地址开始，从高位（地址）向地位（地址）分配。比如，内存区域的结束地址是 0x8000，第一帧假定是 16 字节，那么下一次分配的地址就会从 0x7FF0 开始；第二帧假定需要 64 字节，那么地址就会移到 0x7FB0。

![image.png](https://upload-images.jianshu.io/upload_images/4115164-26e3c3ee5db1547b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

